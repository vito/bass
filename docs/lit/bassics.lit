\title{bassics}
\use-plugin{bass-www}

The following is a list of the built-in types and common terms you will run
into when writing Bass programs.

\table-of-contents

\term{symbol}{
  A name, typically bound to a value in a \t{scope}.
}{
  A symbol form evaluates by fetching its binding in the current \t{scope}.
}{{{
  symbol?
}}}{
  Symbols may be constructed using a \t{keyword} form, analogous to \t{cons}
  forms which construct \t{pairs}.
}{{{
  :symbol?
}}}{
  Symbols are sometimes used as constant values signalling certain conditions,
  such as \bass{:end} to indicate the end of a stream.
}{{{
  (def vals (stream 1 2))

  [(next vals :end)
   (next vals :end)
   (next vals :end)]
}}}{
  Symbols may be chained together with \t{keyword} notation to traverse
  \t{scopes}.
}{{{
  (def foo {:a {:b 42}})
}}}{{{
  foo:a:b
}}}{
  Symbols are \t{applicative} \t{combiners}; when called with a scope, it
  fetches its binding from the scope.

  A default value may be provided as a second argument.
}{{{
  (def foo 123)

  [(:b {:a 1 :b 2 :c 3})
   (:foo (get-current-scope))
   (:b {:a 1} 42)
  ]
}}}

\term{keyword}{
  A symbol prefixed with a \code{:} is called a \italic{keyword}. It is used to
  construct the symbol itself rather than fetch its binding.
}{{{
  :im-a-symbol!
}}}{
  Keywords go hand-in-hand with \t{cons}, which is used to construct
  \t{pairs}.
}{{{
  [:+ 1 2 3]
}}}{
  Note: keywords evaluate to a \t{symbol} - they are not a distinct value.
}

\term{scope}{
  A set of \t{symbols} bound to values, with a list of \italic{parent} scopes
  to query (depth-first) when a local binding is not found.
}{
  All code evaluates in a \italic{current scope}, which is passed to
  \t{operatives} when they are called.
}{{{
  (defop here _ scope scope)

  (let [local-binding "hello"]
    (here))
}}}

\term{bind}{
  \bass{\{bind\}} notation is a \t{scope} literal acting as a map data
  structure.
}{{{
  (eval [str :uri "@" :branch]
    {:uri "https://github.com/vito/bass"
     :branch "main"})
}}}{
  Parent scopes may be provided by listing them anywhere in between the braces.
  For example, here's a scope-based alternative to \bass{(let)}:
}{{{
  (defop with [child & body] parent
    (eval [do & body] {(eval child parent) parent}))

  (with {:a 1 :b 2}
    (+ a b))
}}}{
  Comments within the braces are recorded into the child scope, enabling their
  use for lightweight schema docs:
}{{{
  (eval [doc]
    {; hello world!
     :foo "sup"

     ; goodbye world!
     :bar "later"})
}}}{
  Scopes encode to JSON by converting hyphens to underscores in their bindings.
  This may be slightly surprising but overall it helps with interoperability
  while keeping Bass code looking Lispy.
}{{{
  (dump {:foo-bar "hello!"})
}}}

\term{module}{
  A \t{scope}, typically defined in its own file, providing an interface to
  external modules that use it.

  See \b{provide}, \b{import}, and \b{load}.
}

\term{number}{
  An integer value. Floating point values are not supported.
}{{{
  (* 6 7)
}}}

\term{string}{
  A UTF-8 immutable string value.
}{
  \construction{TODO: document escape sequences}
}{{{
  "hello, world!"
}}}

\term{path}{
  A location of a file or directory within a filesystem.
}{
  Bass distinguishes between file and directory paths by requiring a trailing
  slash (\code{/}) for directories.
}{{{
  (def file ./some-file)
  (def dir ./some-dir/)
  [file dir]
}}}{
  Directory paths can be extended to form longer paths:
}{{{
  dir/file-in-dir
}}}{
  Extending a file path, however, will result in an error.
}{{{
  file/bam
}}}

\term{null}{
  Everyone's old friend. Used to represent the absense of value where one might
  typically be expected.
}{{{
  null
}}}{
  Note: \bass{null} is a distinct type from an empty list. The only
  \bass{(null?)} value is \bass{null}, and the only \bass{(empty?)} value is
  \bass{[]}.
}{{{
  (map null? [[] (list) null false])
}}}

\term{boolean}{
  \bass{true} or \bass{false}, but sometimes \bass{null}.
}{
  Boolean values are pretty straightforward - the only catch is that
  \bass{null} also counts as \bass{false} when given to \bass{(if)} or
  \bass{(not)}.
}{
  Otherwise, all values - including "empty" ones - are truthy.
}{{{
  [(if true :truthy :falsy)
   (if false :truthy :falsy)
   (if null :truthy :falsy)
   (if [] :truthy :falsy)
   (if "" :truthy :falsy)
   (if _ :truthy :falsy)]
}}}

\term{list}{
  A \t{pair} or \t{cons} whose second element is an \t{empty list} or a
  \t{list}.
}{
  A \t{pair} form evaluates by \italic{combining} its first value its second
  value - meaning the first value must be a \t{combiner}.
}{{{
  (list 1 2 3)
}}}{
  A \t{cons} form evaluates like \b{cons}: it constructs a \t{pair} by
  evaluating each of its values.
}{{{
  [1 2 3]
}}}{
  Both \t{pair} and \t{cons} may have a \bass{&} symbol which provides a value
  for the rest of the list.
}{{{
  (def values [1 2 3])
}}}{{{
  (+ & values)
}}}{{{
  [-1 0 & values]
}}}

\term{empty list}{
  An empty list is represented by \bass{()} or \bass{[]}, which are both the
  same constant value.
}{{{
  (= [] ())
}}}

\term{pair}{
  A \t{list} of forms wrapped in \code{(parentheses)}, or constructed via
  \b{cons} or \t{cons} notation.
}{{{
  (= (cons 1 (cons 2 [])) (list 1 2))
}}}{
  A \code{&} may be used to denote the second value instead of terminating with
  an \t{empty list}.
}{{{
  (= (cons 1 2) (list 1 & 2))
}}}

\term{cons}{
  A \t{list} of forms wrapped in \code{[square brackets]}.
}{{{
  (= (cons 1 (cons 2 [])) [1 2])
}}}{
  A \code{&} may be used to denote the second value instead of terminating with
  an \t{empty list}.
}{{{
  (= (cons 1 2) [1 & 2])
}}}

\term{ignore}{
  \bass{_} (underscore) is a special constant value used to discard a value
  when binding values in a scope.
}{{{
  (def (a & _) [1 2 3])

  a ; the only binding in the current scope
}}}{
  \bass{_} is also used when \bass{null} is \italic{just not enough} to express
  how absent a value is - for example, to record overarching commentary within
  a module.
}{{{
  ; Hey ma, I'm a technical writer!
  _
}}}

\term{thunk}{
  A command to be run with inputs provided on standard interfaces (env, stdin,
  args, etc.).
}{
  Thunks are constructed by \italic{applying} a \t{path} specifying the
  command to run. The arguments to a path \t{combiner} provide values to be
  passed to the thunk as a JSON stream on \code{stdin}.
}{
  Throughout this documentation, thunks will be rendered as space invaders.
  Under the hood, thunks are just \t{scopes} with certain bindings - you can
  click them to reveal their inner structure.
}{{{
  (.cat 42)
}}}{
  Thunks are constructed by combining a series of builder functions provided
  by the \reference{stdlib}.

  To pass string arguments to the command, use \bass{(with-args)} - or use the
  \bass{$} operative for syntactic sugar.
}{{{
  (def val "hello")

  [(with-args (.echo) "hi" val)
   ($ echo hi $val)]
}}}{
  Thunks always run in an image of some kind - typically a Docker image
  reference or an OCI image tarball. The image can be provided with
  \b{in-image}.

  The \bass{->} operative comes in especially handy for building thunks by
  chaining constructors together, making it a bit easier to grok.
}{{{
  (-> ($ echo hi $val)
      (in-image "alpine"))
}}}{
  Thunks can have a \italic{response} - a stream of values emitted by the
  command. Running the same thunk must always yield the same response -
  runtimes cache them aggressively.

  The response source can be configured with \b{response-from}, which accepts
  the following sources:

  \list{
    \bass{:stdout} - a JSON stream will be read from the command's stdout
  }{
    a file \t{path} - a JSON stream will be read from the file in the
    thunk's container after it completes
  }{
    \bass{:exit} - the command's exit status will be returned as a single
    integer response value
  }
}{{{
  (-> (.cat 42)
      (in-image "alpine")
      (response-from :stdout))
}}}{
  To run a thunk, pass it to \bass{(run)}; it will return a \t{source} from
  which you can read the response using \bass{(next)}.

  Let's put all this together to implement the world's least efficient identity
  function:
}{{{
  (defn id [x]
    (-> (.cat x)
        (in-image "alpine")
        (response-from :stdout)
        run
        next))

  (time [(id "hello") (id "it me")])
}}}

\term{runtime}{
  An internal component used for running thunks, configured by the user and
  associated to a \t{platform}.
}{
  Currently, only Docker is supported - Kubernetes support may come in the
  future.
}

\term{platform}{
  A scope containing arbitrary bindings used to select the appropriate
  configured \t{runtime} for a given \t{thunk}.
}

\term{thunk path}{
  A \t{path} paired with the \t{thunk} that created (or creates) it.
}{{{
  (path (.run) ./some-file)
}}}{
  Thunk paths can be constructed and passed around to other thunks as
  first-class values. The \t{runtime} will handle the boring mechanical work of
  mounting it into the container in the right place.
}{{{
  (def touchi-artist
    (-> ($ touch ./artist)
        (in-image "alpine")
        (path ./artist)))

  (-> ($ ls $touchi-artist)
      (in-image "alpine")
      (response-from :exit)
      run
      next)
}}}{
  Thunk paths represent \italic{reproducible artifacts} - when passed from
  one thunk into another, any paths created by the child thunk will be
  inherently downstream of all of its inputs. The thunk path may be exported
  to JSON format and used to re-create the artifact from scratch with
  \code{bass -e < wlp.json}.
}

\term{pipe}{
  A pipe is a \t{source} with a corresponding \t{sink}.
}

\term{source}{
  A stream of values which may be read with \bass{(next)}.
}{
  All scripts can read values from the \bass{*stdin*} source, which reads JSON
  encoded values from \code{stdin}.

  A source may be constructed from a sequence of values by calling
  \bass{(stream)}.
}{{{
  (def vals (stream 1 2 3))
  [(next vals)
   (next vals)
   (next vals)]
}}}{
  A \t{source} is also returned by \bass{(run)} to pass along values emitted by
  the thunk.

  When \bass{(next)} hits the end of the stream, an error will be raised. A
  default value may be supplied as the second argument to prevent erroring.
}

\term{sink}{
  A destination for values which may be sent with \bass{(emit)}.
}{
  All scripts can emit values to the \bass{*stdout*} sink, which encodes values
  as JSON to \code{stdout}.
}{{{
  (emit "hello!" *stdout*)
  (emit 42 *stdout*)
}}}

\term{combiner}{
  A value which can be \italic{applied} to another value (typically a list of
  arguments) to perform some computation and return another value.
}

\term{operative}{
  A \t{combiner} which receives the applied arguments, \italic{unevaluated},
  along with the dynamic \t{scope} of the caller.
}{
  Operatives are defined with the \bass{(defop)} operative or constructed with
  \bass{(op)}.
}{{{
  (defop quote-with-scope args scope
    [args scope])

  (quote-with-scope a b c)
}}}

\term{applicative}{
  A \t{combiner} which \italic{wraps} an underlying \t{operative} and evaluates
  its arguments before passing them along to it.
}{
  Applicatives, typically called \italic{functions}, are defined with the
  \bass{(defn)} operative or constructed with \bass{(fn)}.
}{{{
  (defn inc [x]
    (+ x 1))

  (inc 41)
}}}

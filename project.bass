(use (.git (linux/alpine/git)))

; root of the git repository
(def *root*
  *dir*)

; clones the repo and checks out the given sha
(defn checkout [sha]
  (git:github/vito/bass/sha/ sha))

(provide [build tests docs]
  ; runs a quick sanity check
  (defn check-binary [binary image]
    (run (from image
           ($ $binary --version)))

    (if (succeeds? (from image
                     ($ ldd $binary)))
      (error "binary is not statically linked")
      :ok))

  (defn tar-czf [tarname dir & files]
    (-> ($ tar -C $dir -czf $tarname & $files)
        (with-image (linux/alpine))
        (subpath tarname)))

  (defn zip [zipname dir & files]
    (-> ($ zip (../ zipname) & $files)
        (with-image (from (linux/alpine) ($ apk add zip)))
        (with-dir dir)
        (subpath zipname)))

  (defn archive [out os arch]
    (let [prefix (str "bass." os "-" arch)
          tgz-path (string->fs-path (str prefix ".tgz"))
          zip-path (string->fs-path (str prefix ".zip"))]
      (case os
        "linux"
        (do
          ; check that the binary works in a few common images
          (map (fn [image] (check-binary out/bass image))
               [(linux/ubuntu)
                (linux/alpine)])

          (tar-czf tgz-path out ./bass))

        "darwin"
        (tar-czf tgz-path out ./bass)

        "windows"
        (zip zip-path out ./bass))))

  (def nvim-uri
    "https://github.com/neovim/neovim/releases/download/v0.6.1/nvim-linux64.tar.gz")

  (defn deps [src]
    (from (linux/golang :1.17)
      ; install buildkit + friends globally
      ($ *root*/hack/buildkit/setup /usr/bin)

      ; for lsp tests
      ($ sh -c "curl -sSL $0 | tar -xzf - -C /usr/local --strip-components=1" $nvim-uri)
      ($ nvim --version)

      ; to be able to re-use hack/ scripts
      ($ apt-get update)
      ($ apt-get -y install sudo)

      ; prettier test output
      ($ go install "gotest.tools/gotestsum@latest")

      ; cache these separately as they don't change often
      ($ cp src/go.mod src/go.sum ./)
      ($ go mod download)))

  (defn shim-bin [src arch]
    (let [file (string->fs-path (str "exe." arch))]
      (-> ($ go build -o (./out/ file) -trimpath ./shim/)
          (with-image (deps src)) ; TODO: match this to os/arch
          (with-mount src/pkg/runtimes/shim/ ./shim/)
          (with-env {:GOOS "linux" :GOARCH arch :CGO_ENABLED "0"})
          (subpath (./out/ file)))))

  (defn all-shims [src]
    (let [arches ["amd64" "arm" "arm64" "ppc64le" "riscv64" "s390x"]
          all-shims (map (fn [a] (shim-bin src a)) arches)
          cp-args (conj all-shims ./)
          exes (subpath (from (linux/golang) ($ cp & $cp-args)) ./)]
      ; just to see how much we're packing in to the binary
      (run (from (linux/alpine)
             ($ ls -alh $exes)))
      exes))

  ; compiles a bass binary for the given platform and puts it in an archive
  (defn build [src os arch]
    (-> ($ go build -o ../out/bass -trimpath ./cmd/bass)
        (with-image (deps src)) ; TODO: match this to os/arch?
        (with-dir ./src/)
        (with-mount src ./src/)
        (with-mount (all-shims src) ./src/pkg/runtimes/shim/bin/)
        (with-env {:GOOS os :GOARCH arch :CGO_ENABLED "0"})
        (subpath ./out/)
        (archive os arch)))

  (defn with-deps [src test-thunk]
    (from (deps src)
      ; install bass
      ($ tar -zxf (build src "linux" "amd64") -C /usr/local/bin/)

      (-> test-thunk

          (with-mount src ./src/)
          (with-mount (all-shims src) ./src/pkg/runtimes/shim/bin/)
          (with-dir ./src/)

          ; wrap command
          (wrap-cmd ./hack/with-deps)

          ; runtime tests currently need elevated privileges
          insecure!

          ; cache state to reduce Docker API calls
          (with-mount /bass-cache/bass/ /root/.cache/bass/)
          (with-mount /bass-cache/buildkit/ /var/lib/buildkit/))))

  ; returns a directory containing the built docs HTML
  (defn docs [src]
    (subpath
      (with-deps src
        ($ ./docs/scripts/build ../out/))
      ./out/))

  ; returns a thunk that will run the tests and return cover.html
  (defn tests [src testflags]
    (from (with-deps src
            ($ gotestsum --format standard-verbose --no-color=false --jsonfile ../tests.log
               --
               -cover
               -coverprofile ../cover.out
               -covermode count
               & $testflags))

      ; report slow tests
      ($ gotestsum tool slowest --jsonfile ./tests.log --threshold "500ms")

      ; generate coverage report
      (cd src ($ go tool cover -html ../cover.out -o ../cover.html)))))

; checks that the nix flake + build can run successfully
(defn nix-checks [src]
  (from (linux/nixpkgs/nix-flakes)
    (cd src
      ($ nix flake metadata)
      ($ nix flake check)
      ($ nix build))))

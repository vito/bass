(use (.git (linux/alpine/git)))

; url of the git repository
(def url
  "https://github.com/vito/bass")

; root of the local checkout of the git repository
(def *root*
  *dir*)

; resolves a ref to a sha
(defn resolve-ref [ref]
  (git:ls-remote url ref))

; clones the repo and checks out the given sha
(defn checkout [sha]
  (git:checkout url sha))

(provide [build]
  ; runs a quick sanity check
  (defn check-binary [binary image]
    (run (from image
           ($ $binary --version)))

    (if (succeeds? (from image
                     ($ ldd $binary)))
      (error "binary is not statically linked")
      :ok))

  (defn shim-bin [src arch]
    (let [file (string->fs-path (str "pkg/runtimes/shim/bin/exe." arch))]
      (subpath
        (from (linux/golang)
          (cd src
            (-> ($ sh -c "make $0 && cp $0 ../" $file) (with-env {:GOARCH arch}))))
        (string->fs-path (path-name file)))))

  (defn all-shims [src]
    (subpath
      (from (linux/golang)
        ($ cp
           (shim-bin src "amd64")
           (shim-bin src "arm")
           (shim-bin src "arm64")
           (shim-bin src "ppc64le")
           (shim-bin src "riscv64")
           (shim-bin src "s390x")
           ./))
      ./))

  (defn bass-bin [src os arch]
    (let [output (string->fs-path (str "bass-" os "-" arch))]
      (subpath
        (from (linux/golang) ; TODO: use a platform in sync with 'os' someday
          (-> ($ go build -o (../ output) ./cmd/bass)
              (in-dir ./src/)
              (with-mount src ./src/)
              (with-mount (all-shims src) ./src/pkg/runtimes/shim/bin/)
              (with-env {:GOOS os :GOARCH arch :CGO_ENABLED "0"})))
        output)))

  ; compiles a bass binary for the given platform
  (defn build [src os arch]
    (let [binary (bass-bin src os arch)]
      ; check that the binary works in a few common images
      (map (fn [image] (check-binary binary image))
           [(linux/ubuntu)
            (linux/alpine)])

      binary)))

; checks that the nix flake + build can run successfully
(defn nix-checks [src]
  (from (linux/nixpkgs/nix-flakes)
    (cd src
      ($ nix flake metadata)
      ($ nix flake check)
      ($ nix build))))

; returns a directory containing the built docs HTML
(defn docs [src]
  (subpath
    (with-deps src
      ($ ./docs/scripts/build ../out/))
    ./out/))

(provide [tests]
  (def nvim-uri
    "https://github.com/neovim/neovim/releases/download/v0.6.0/nvim-linux64.tar.gz")

  (def test-deps
    (from (linux/golang :1.17)
      ; install buildkit + friends globally
      ($ *root*/hack/buildkit/setup /usr/bin)

      ; for lsp tests
      ($ sh -c "curl -sSL $0 | tar -xzf - -C /usr/local --strip-components=1" $nvim-uri)
      ($ nvim --version)

      ; to be able to re-use hack/ scripts
      ($ apt-get update)
      ($ apt-get -y install sudo)

      ; prettier test output
      ($ go install "gotest.tools/gotestsum@latest")))

  (defn with-deps [src test-thunk]
    (from test-deps
      ; cache these separately as they don't change often
      ($ cp src/go.mod src/go.sum ./)
      ($ go mod download)

      (cd src
        ; install bass for lsp tests and running demos in docs
        ($ make install)
        ($ bass --version)

        (-> test-thunk

            ; wrap command
            (wrap-cmd ./hack/with-deps)

            ; runtime tests currently need elevated privileges
            insecure!

            ; cache state to reduce Docker API calls
            (with-mount /bass-cache/bass/ /root/.cache/bass/)
            (with-mount /bass-cache/buildkit/ /var/lib/buildkit/)))))

  ; returns a thunk that will run the tests and return cover.html
  (defn tests [src testflags]
    (from (with-deps src
            ($ gotestsum --format dots --no-color=false --jsonfile ../tests.log
               --
               -cover
               -coverprofile ../cover.out
               -covermode count
               & $testflags))

      ; report slow tests
      ($ gotestsum tool slowest --jsonfile ./tests.log --threshold "500ms")

      ; generate coverage report
      (cd src ($ go tool cover -html ../cover.out -o ../cover.html)))))

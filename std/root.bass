; construct a list from a sequence of values
;
; => (list 1 2 3)
(def list (wrap (op values _ values)))

; prepend a sequence of values to a list given as the final argument
;
; => (list* 1 2 3 [4 5])
(def list*
  (wrap
    (op args _
      (do
        (def aux
          (wrap
            (op ((head & tail)) _
              (if (empty? tail)
                head
                (cons head (aux tail))))))
        (aux args)))))

; return the first value in a pair
;
; => (first [1 2 3])
(def first (wrap (op [(f & _)] _ f)))

; return the second value in a pair, i.e. the rest of a linked list
;
; => (rest [1 2 3])
(def rest (wrap (op [(_ & r)] _ r)))

; return the length of the given list
;
; => (length [1 2 3])
(def length
  (wrap
    (op [xs] _
        (if (empty? xs)
          0
          (+ 1 (length (rest xs)))))))

; construct an operative
;
; An operative is a combiner that is called with unevaluated arguments and the
; caller's dynamic scope.
;
; Operatives are used to define new syntax forms.
;
; => (def quote (op [x] _ x))
;
; => (quote abc)
^:indent
(def op
  ((wrap
     (op (op) _
         (op [formals eformal & body] scope
           (eval [op formals eformal
                  (if (> (length body) 1)
                    (cons do body)
                    (first body))]
                 scope))))
   op))

; construct an operative and bind it to a symbol
;
; Returns the bound symbol. Write a comment before (defop) to provide
; documentation.
;
; => (defop quote [x] _ x)
;
; => (quote abc)
^:indent
(def defop
  (op [name formals eformal & body] scope
    (eval [def name [op formals eformal & body]] scope)))

; construct a function
;
; Functions are applicative combiners which evaluate their arguments before
; passing them to an underlying operative.
;
; => (def times-7 (fn [x] (* x 7)))
;
; => (times-7 6)
^:indent
(defop fn [formals & body] scope
  (wrap (eval [op formals _ & body] scope)))

; construct a function and bind it to a symbol
;
; Returns the bound symbol. Write a comment before (defn) to provide
; documentation.
;
; => (defn times-7 [x] (* x 7))
;
; => (times-7 6)
^:indent
(defop defn [name formals & body] scope
  (eval [def name [fn formals & body]] scope))

; return the second member of a linked list
;
; => (second [1 2 3])
(defn second [(_ x & _)]   x)

; return third member of a linked list
;
; => (third [1 2 3])
(defn third  [(_ _ x & _)] x)

; returns the scope of the caller
;
; => (current-scope)
;
; => (eval [current-scope] {:a 1})
(defop current-scope [] scope scope)

; returns the unevaluated form
;
; => (quote abc)
(defop quote [form] _ form)

; returns a list containing the result of applying f to each member of xs
;
; => (map (fn [x] (* x 7)) [5 6 7])
(def map
  (fn [f xs]
    (if (empty? xs)
      ()
      (cons (f (first xs))
            (map f (rest xs))))))

; calls a function with alternating pairs in a flat list (i.e. with pairs ungrouped)
;
; Takes 2-arity function and a flat pair sequence. Walks the sequence and calls
; f with 2 values at a time.
;
; Raises an error if the list has uneven length.
;
; => (map-pairs cons [:a 1 :b 2 :c 3])
(defn map-pairs [f ps]
  (defn map-pairs-acc [f a ps]
    (if (empty? ps)
      (if (null? a)
        []
        (error "syntax: uneven pairs"))
      (if (null? a)
        (map-pairs-acc f (first ps) (rest ps))
        (cons (f a (first ps))
              (map-pairs-acc f null (rest ps))))))

  (map-pairs-acc f null ps))

; binds values in a child scope
;
; Takes a list alternating bindings and their values. Creates a child scope,
; and binds and evaluates each value in sequence. Later bindings may to refer
; to earlier bindings.
;
; Returns the result of evaluating the body in the child scope.
;
; => (let [x 6 y 7] (* 6 7))
^:indent
(defop let (bindings & body) scope
  (def child (make-scope scope))

  (map-pairs
    (fn [binding val]
      (eval [def binding val] child))
    bindings)

  (eval [do & body] child))

; binds symbols in the current scope to their values from the source
; scope
;
; => (import {:x 6 :y 7} x)
;
; => x ; y is not bound
(defop import [source & symbols] scope
  (let [inner (eval source scope)]
    (map
      (fn [sym]
        (let [val-thunk [(unwrap eval) sym inner]]
          (eval [def sym val-thunk] scope)
          sym))
      symbols)))

; provide bindings to the current scope from a nested scope
;
; Allows for modularity in code, selectively providing bindings while
; encapsulating bindings that they use.
;
; => (provide [y] (def x 6) (def y 7))
;
; => y ; x is not bound
^:indent
(defop provide [symbols & body] scope
  (let [inner (make-scope scope)]
    (eval [do & body] inner)
    (eval [import inner & symbols] scope)))

(provide [use]
  (defn bind-modules [args scope]
    (case args
      [] []
      [thunk-form & rest-forms]
      (let [thunk (eval thunk-form scope)
            modname (string->symbol (path-name (thunk-cmd thunk)))]
        (cons (eval [def modname [load thunk]] scope)
              (bind-modules rest-forms scope)))))

  ; loads each thunk and binds it as the name from the thunk's command path
  ;
  ; That is, (use (.foo)) is equivalent to (def foo (load (.foo))).
  ;
  ; => (use (.strings) (.time))
  ;
  ; => (strings:upper-case "hallelujah")
  ;
  ; => (time:yearly)
  (defop use thunks scope
    (bind-modules thunks scope)))

(provide [cond]
  (defn cond-pairs [f a ps]
    (if (empty? ps)
      (if (null? a)
        null
        uneven-pairs) ; TODO: proper error
      (if (null? a)
        (cond-pairs f (first ps) (rest ps))
        (do
          (def (ok & res) (f a (first ps)))
          (if ok
            res
            (cond-pairs f null (rest ps)))))))

  ; if-then-else, but with many clauses
  ;
  ; Takes a flat pair sequence alternating tests to evaluate and an
  ; expression to evaluate if the test returns a truthy value.
  ;
  ; Returns the result of the evaluated branch, or null if no tests were true.
  ;
  ; By convention, :else is used as the final catch-all test, though any
  ; truthy value works.
  ;
  ; => (cond false :a false :b :else :c)
  ;
  ; => (cond true :a false :b :else :c)
  ^:indent
  (defop cond clauses scope
    (cond-pairs
      (fn [test body]
        (if (eval test scope)
          (cons true (eval body scope))
          (cons false null)))
      null
      clauses)))

; returns the first truthy value returned by evaluating conds
;
; Short-circuits when it encounters a truthy value.
;
; Returns false if no values are given.
;
; => (or false null :yep)
;
; => (or)
(defop or conds scope
  (cond
    (empty? conds)
      false

    (= 1 (length conds))
      (eval (first conds) scope)

    :else
      (let [(x & xs) conds
            xv (eval x scope)]
        (if xv
          xv
          (eval [or & xs] scope)))))

; returns a truthy value if none of the conds return a falsy value
;
; Short-circuits when it encounters a falsy value.
;
; Returns true if no values are given.
;
; => (or false null :yep)

; => (and)
(defop and conds scope
  (cond
    (empty? conds)
      true

    (= 1 (length conds))
      (eval (first conds) scope)

    :else
      (let [(x & xs) conds
            xv (eval x scope)]
        (if xv
          (eval [and & xs] scope)
          xv))))

; call an applicative's underlying operative with a list of arguments
;
; A scope may be provided as the third argument. If not specified, the
; operative will be called in a new empty scope.
;
; Used to call an applicative with pre-evaluated arguments, skipping the normal
; evaluation the applicative would perform prior to calling the underlying
; operative.
;
; => (apply * [1 2 3])
(defn apply [appv arg & opt]
  (eval (cons (unwrap appv) arg)
        (if (empty? opt)
          (make-scope)
          (first opt))))

(provide (->)
  ; passes a value through a series of function calls
  ;
  ; Given an input value and a series of functions, calls the first function
  ; with the input value, passing the output to the second function, and so on,
  ; returning the final value. Typically used to flatten a deeply nested
  ; function call to make it easier to read.
  ;
  ; Functions are either a single form (i.e. a symbol) or a pair. A single form
  ; is called with the input value as the only argument. A pair is called with
  ; the input value prepended to the rest of the pair, i.e. inserted as the
  ; first argument.
  ;
  ; => (-> (.boom) insecure! (with-env {:BAM "hi"}))
  ;
  ; => (-> 6 (* 7) (- 2) (quot 4))
  (defop -> [x f & fs] scope
    (let [v (if (pair? f)
              (let [(f' & as) f]
                [f' x & as])
              [f x])]
      (if (empty? fs)
        (eval v scope)
        (eval [-> v & fs] scope)))))

(provide (case)
  (defn case-branches [scope val branches]
    (if (empty? branches)
      (errorf "no matching case branch: %s" val)
      (let [[pattern expr & rest] branches
            child (make-scope scope)]
        (if (bind child pattern val)
          (eval expr child)
          (case-branches scope val rest)))))

  ; evaluates the branch that successfully binds the given value
  ;
  ; Bindings are set in an child scope.
  ;
  ; => (case [] [] :empty [x] :one _ :more)
  ;
  ; => (case [1] [] :empty [x] :one _ :more)
  ;
  ; => (case [1 2] [] :empty [x] :one _ :more)
  ^:indent
  (defop case [v & bs] scope
    (case-branches scope (eval v scope) bs)))

; identity function; returns its argument
;
; => (id 42)
;
; => (id id)
;
; => ((id id) id)
;
; => (((id id) id) id)
(defn id [x] x)

; collects the values from a scope
;
; => (vals {:a 1 :b 2})
(defn vals [scope]
  (reduce-kv (fn [a _ v] (conj a v)) [] scope))

; collects the bindings from a scope
;
; => (keys {:a 1 :b 2})
(defn keys [scope]
  (reduce-kv (fn [a k _] (conj a k)) [] scope))

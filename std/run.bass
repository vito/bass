; returns a structure which will join the given values into a single string value
;
; Used to concatenate paths with string values to be passed as an argument to a
; thunk.
(defn arg vals
  {:arg vals})

; detects whether the value is an arg structure
;
; Concretely, this is any scope with an :arg binding.
(defn arg? [val]
  (if (and (scope? val) val:arg)
    true
    ; normalize falsy value to false
    false))

; prepend a run-path + args to a thunk's command
;
; Replaces the thunk's run path sets its args to and prepend-args prepended to
; the original run path + args.
(defn wrap-cmd [thunk run-path & prepend-args]
  (assoc thunk
         :path run-path
         :args (append prepend-args [thunk:path & thunk:args])))

; sets the :args field of the thunk
(defn with-args [thunk & args]
  (assoc thunk :args args))

; sets the :stdin field of the thunk
(defn with-stdin [thunk & stdin]
  (assoc thunk :stdin stdin))

; sets the :insecure field of the thunk to true
(defn insecure! [thunk]
  (with-insecure thunk true))

; sets the :insecure field of the thunk
(defn with-insecure [thunk val]
  (assoc thunk :insecure val))

(provide ($)
  (defn resolve-arg [a scope]
    (if (symbol? a)
      (let [word (symbol->string a)
            start (substring word 0 1)]
        (if (= start "$")
          (eval (string->symbol (substring word 1)) scope)
          (eval word scope)))
      (eval a scope)))

  (defn resolve-cmd [a scope]
    (let [val (resolve-arg a scope)]
      (if (string? val)
        (string->run-path val)
        val)))

  (defn resolve-args [args scope]
    (case args
      [] []
      [a & as] (cons (resolve-arg a scope)
                     (resolve-args as scope))
      splat (resolve-arg splat scope)))

  ; constructs a thunk with args set as :args
  ;
  ; Symbol arguments are automatically converted to strings. Symbols beginning
  ; with $ are resolved to their binding with the leading $ removed.
  (defop $ [cmd & args] scope
    (let [c (resolve-cmd cmd scope)
          as (resolve-args args scope)]
      (apply with-args [(c) & as]))))

(def linux
  {:os "linux"})

(def windows
  {:os "windows"})

(def darwin
  {:os "darwin"})

; the default platform for thunks that configure an image
(def *default-platform*
  linux)

(provide [in-image]
  (defn resolve-image [image]
    (if (string? image)
      {:platform *default-platform*
       :repository image}
      image))

  ; sets the :image field of the thunk
  (defn in-image [thunk image]
    (assoc thunk
           :image (if thunk:image
                    (in-image thunk:image image)
                    (resolve-image image)))))

; chain a sequence of thunks starting from an initial image
^:indent
(defn from [image & thunks]
  (foldl (fn [base cmd] (in-image cmd base)) image thunks))

; chain a sequence of thunks with a given working directory
;
; Shorthand for applying (in-dir) to each thunk and chaining them with (from).
;
; Typically used within an outer (from) which sets first command's image in
; order to join it into the chain.
^:indent
(defn cd [dir & thunks]
  (apply from (map (fn [thunk] (in-dir thunk dir)) thunks)))

; sets the :response field of the thunk
;
; If source is :stdout, sets it to {:stdout true}.
; If source is :exit, sets it to {:exit-code true}.
; If source is a path?, sets it to {:file source}.
(defn response-from [thunk source & optional-protocol]
  (let [protocol (if (empty? optional-protocol)
                   "json"
                   (str (first optional-protocol)))]
    (assoc thunk
           :response
           (cond
             (= :stdout source) {:stdout true :protocol protocol}
             (= :exit source) {:exit-code true :protocol protocol}
             (path? source) {:file source :protocol protocol}
             :else (errorf "unknown response: %s" source)))))

; sets the :dir field of the thunk
(defn in-dir [thunk dir]
  (assoc thunk :dir dir))

; appends a mount to the :mounts field of the thunk
(defn with-mount [thunk source target]
  (let [cur (:mounts thunk [])]
    (assoc thunk
           :mounts
           (conj cur {:source source :target target}))))

; sets the :mounts field of the thunk
(defn with-mounts [thunk mounts]
  (assoc thunk :mounts mounts))

; inserts an env var and value into the :env field of the thunk
;
; TODO: append, add in stable order
(defn with-env-var [thunk name value]
  (assoc thunk :env (assoc (:env thunk {}) name value)))

; sets the :env field of the thunk
(defn with-env [thunk env]
  (assoc thunk :env env))

; annotates the thunk with an arbitrary key-value label
;
; Labels are typically used to control caching. Two thunks that differ only in
; labels will evaluate separately and produce independent results.
(defn with-label [thunk key val]
  (assoc thunk :labels (assoc (:labels thunk {}) key val)))
